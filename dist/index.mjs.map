{"version":3,"sources":["../src/lib/httpClient.ts","../src/lib/logger.ts","../src/client.ts"],"sourcesContent":["import qs from \"qs\";\n\nimport { logger } from \"./logger\";\n\nconst cache =\n  (process.env.NEXT_PUBLIC_CACHE_CONTROL as RequestCache) || \"force-cache\";\nconst revalidate = Number(process.env.NEXT_PUBLIC_REVALIDATE) || false;\n\ntype HTTPMethods = \"GET\" | \"POST\" | \"PATCH\" | \"DELETE\" | \"PUT\";\n\ntype Headers = Record<string, any>;\ntype NextConfigProps = {\n  revalidate?: number | false;\n  tags?: string[];\n};\ntype RequestProps = {\n  headers?: Headers;\n  query?: any;\n  nextConfig?: NextConfigProps;\n};\n\nexport interface GetOpts extends RequestProps {}\n\ntype BodyProps = {\n  type?: \"POST\" | \"PATCH\" | \"PUT\";\n  body?: any;\n  [x: string]: any;\n};\n\nexport type HttpClient = {\n  request: (\n    endpoint: string,\n    method: HTTPMethods,\n    options?: RequestProps & BodyProps\n  ) => Promise<any>;\n  get: <T>(endpoint: string, props?: GetOpts) => Promise<T>;\n  post: <T>(endpoint: string, props?: BodyProps) => Promise<T>;\n  patch: <T>(endpoint: string, props?: BodyProps) => Promise<T>;\n  put: <T>(endpoint: string, props?: BodyProps) => Promise<T>;\n  delete: <T>(endpoint: string, props?: RequestProps) => Promise<T>;\n};\n\nexport type HttpClientProps = {\n  url: string;\n  log?: boolean;\n  headers?: () => Headers;\n} & HttpClientHelpers;\n\nexport type HttpClientHelpers = {\n  beforeRequest?: (props: { url: string } & RequestInit) => void;\n  afterRequest?: (response: any) => void;\n  parseResponse?: (response: any) => any;\n};\nexport function httpClient(props: HttpClientProps): HttpClient {\n  const buildUrl = (endpoint: string, query?: any): string => {\n    const queryString = qs.stringify(query, { addQueryPrefix: true });\n    return `${props.url}/${endpoint}${queryString}`;\n  };\n\n  const fetchJson = async (\n    url: string,\n    method: HTTPMethods,\n    headers: Headers,\n    next?: NextConfigProps,\n    body?: any\n  ): Promise<any> => {\n    const requestOpts: RequestInit = {\n      method,\n      credentials: \"include\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        \"Cache-Control\": cache,\n        ...headers,\n      },\n      body: JSON.stringify(body),\n\n      // @ts-ignore\n      next: {\n        revalidate: revalidate,\n        tags: [\"payload\"],\n        ...next,\n      },\n    };\n\n    try {\n      if (props.beforeRequest) {\n        props.beforeRequest({ url, ...requestOpts });\n      }\n\n      const response = await fetch(url, requestOpts);\n      if (!response.ok) {\n        throw new Error(response.statusText);\n      }\n\n      const data = await response.json();\n\n      if (props.afterRequest) {\n        props.afterRequest(data);\n      }\n\n      return props.parseResponse ? props.parseResponse(data) : data;\n    } catch (error) {\n      logger.error(`Error fetching ${url}`, error);\n      throw error;\n    }\n  };\n\n  const request: HttpClient[\"request\"] = async (\n    endpoint,\n    method,\n    options = {}\n  ) => {\n    const url = buildUrl(endpoint, options.query);\n\n    const headers = options.headers || {};\n    if (props.headers) {\n      Object.assign(headers, props.headers());\n    }\n\n    return fetchJson(url, method, headers, options.nextConfig, options.body);\n  };\n\n  const postRequest: HttpClient[\"post\"] = async (endpoint, props) =>\n    request(endpoint, \"POST\", props);\n  const putRequest: HttpClient[\"put\"] = async (endpoint, props) =>\n    request(endpoint, \"PUT\", props);\n  const patchRequest: HttpClient[\"patch\"] = async (endpoint, props) =>\n    request(endpoint, \"PATCH\", props);\n\n  return {\n    request,\n    get: (endpoint, props) => request(endpoint, \"GET\", props),\n    delete: (endpoint, props) => request(endpoint, \"DELETE\", props),\n    post: postRequest,\n    put: putRequest,\n    patch: patchRequest,\n  };\n}\n","import { pino } from \"pino\";\n\nconst env = process.env.NODE_ENV || \"development\";\n\nexport const createLogger = (props?: { name?: string }) => {\n  if (env === \"production\") {\n    return pino({ name: props?.name });\n  }\n\n  // const pretty = require(\"pino-pretty\");\n  // const stream = pretty({\n  //   colorize: true,\n  // });\n  return pino({ name: props?.name });\n};\n\nexport const logger = createLogger();\n","import { GeneratedTypes } from \"payload\";\nimport { Options as FindOptions } from \"payload/dist/collections/operations/local/find\";\nimport { PaginatedDocs } from \"payload/dist/database/types\";\nimport { httpClient, HttpClient, HttpClientProps } from \"@/lib/httpClient\";\n\nexport class PayloadClient<TGeneratedTypes extends GeneratedTypes> {\n  private client: HttpClient;\n\n  constructor(props: HttpClientProps) {\n    const { url, ...rest } = props;\n    this.client = httpClient({\n      url: `${url}/api`,\n      ...rest,\n    });\n  }\n\n  find = async <T extends keyof TGeneratedTypes[\"collections\"]>(\n    options: FindOptions<T>\n  ): Promise<PaginatedDocs<TGeneratedTypes[\"collections\"][T]>> => {\n    const { collection, ...rest } = options;\n\n    return this.client.get(collection as string, {\n      query: rest,\n    });\n  };\n}\n"],"mappings":"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","names":["props"]}